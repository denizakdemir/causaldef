# =============================================================================
# REST API via Plumber for CausalDef
# =============================================================================

#' Create Plumber API for CausalDef
#'
#' Generates a plumber API definition file for deploying causaldef as a
#' REST service. This enables integration with web applications, dashboards,
#' and other programming languages.
#'
#' @param path Directory to write the API files
#' @param port Integer: default port for the API (default 8080)
#'
#' @return Invisibly returns the path to the created files
#'
#' @details
#' The API provides the following endpoints:
#'
#' \itemize{
#'   \item \code{POST /deficiency}: Estimate deficiency from uploaded data
#'   \item \code{POST /policy-bound}: Calculate policy regret bounds
#'   \item \code{POST /frontier}: Generate confounding frontier
#'   \item \code{GET /health}: Health check endpoint
#'   \item \code{GET /methods}: List available methods
#' }
#'
#' @examples
#' \dontrun{
#' # Create API files
#' create_plumber_api("my_api")
#'
#' # Run the API
#' plumber::plumb("my_api/plumber.R")$run(port = 8080)
#' }
#'
#' @seealso [run_causaldef_app()]
#' @export
create_plumber_api <- function(path = "causaldef_api", port = 8080) {
  
  if (!dir.exists(path)) {
    dir.create(path, recursive = TRUE)
  }
  
  # Main plumber.R file
  plumber_code <- sprintf('
# =============================================================================
# CausalDef REST API
# Generated by causaldef::create_plumber_api()
# =============================================================================

library(plumber)
library(causaldef)
library(jsonlite)

#* @apiTitle CausalDef API
#* @apiDescription Decision-theoretic causal diagnostics via Le Cam deficiency
#* @apiVersion 0.2.0
#* @apiContact list(name = "CausalDef", url = "https://github.com/denizakdemir/causaldef")

# =============================================================================
# Health & Info Endpoints
# =============================================================================

#* Health check
#* @get /health
function() {
  list(
    status = "healthy",
    version = as.character(packageVersion("causaldef")),
    timestamp = Sys.time()
  )
}

#* List available estimation methods
#* @get /methods
function() {
  list(
    standard = c("unadjusted", "iptw", "aipw", "tmle", "matching", "grf"),
    survival = c("unadjusted", "iptw", "aipw", "tmle", "matching", "cox_iptw"),
    description = list(
      unadjusted = "No adjustment (baseline)",
      iptw = "Inverse probability of treatment weighting",
      aipw = "Augmented IPW (doubly robust)",
      tmle = "Targeted maximum likelihood estimation",
      matching = "Propensity score matching (MatchIt)",
      grf = "Generalized random forests (causal forest)",
      cox_iptw = "IPTW-weighted Cox model for survival"
    )
  )
}

# =============================================================================
# Core Analysis Endpoints
# =============================================================================

#* Estimate Le Cam deficiency
#* @param data:object The dataset as JSON array of objects
#* @param treatment:str Name of treatment variable
#* @param outcome:str Name of outcome variable
#* @param covariates:arr Names of covariate variables
#* @param methods:arr Methods to use (default: ["iptw", "aipw"])
#* @param n_boot:int Bootstrap samples (default: 100)
#* @post /deficiency
function(data, treatment, outcome, covariates = NULL, 
         methods = c("iptw", "aipw"), n_boot = 100) {
  
  tryCatch({
    # Parse data
    df <- as.data.frame(jsonlite::fromJSON(data))
    
    # Create spec
    spec <- causal_spec(
      data = df,
      treatment = treatment,
      outcome = outcome,
      covariates = covariates
    )
    
    # Estimate deficiency
    result <- estimate_deficiency(
      spec,
      methods = methods,
      n_boot = as.integer(n_boot),
      verbose = FALSE
    )
    
    # Return structured result
    list(
      success = TRUE,
      estimates = as.list(result$estimates),
      se = as.list(result$se),
      ci = list(
        lower = result$ci[, 1],
        upper = result$ci[, 2]
      ),
      best_method = names(which.min(result$estimates)),
      recommendation = if (min(result$estimates) < 0.05) {
        "Excellent: causal identification appears reliable"
      } else if (min(result$estimates) < 0.10) {
        "Moderate: proceed with caution"
      } else {
        "Concerning: consider additional adjustment or RCT"
      }
    )
    
  }, error = function(e) {
    list(success = FALSE, error = e$message)
  })
}

#* Calculate policy regret bound
#* @param delta:num Deficiency estimate
#* @param utility_min:num Minimum utility value
#* @param utility_max:num Maximum utility value
#* @param obs_regret:num Observed regret (optional)
#* @post /policy-bound
function(delta, utility_min = 0, utility_max = 1, obs_regret = NULL) {
  
  tryCatch({
    M <- utility_max - utility_min
    safety_floor <- 2 * M * as.numeric(delta)
    
    result <- list(
      success = TRUE,
      delta = as.numeric(delta),
      M = M,
      safety_floor = safety_floor
    )
    
    if (!is.null(obs_regret)) {
      result$obs_regret <- as.numeric(obs_regret)
      result$regret_bound <- safety_floor + as.numeric(obs_regret)
    }
    
    result$interpretation <- sprintf(
      "With delta=%%.3f and utility range [%%.1f, %%.1f], the minimum irreducible regret is %%.3f",
      as.numeric(delta), utility_min, utility_max, safety_floor
    )
    
    result
    
  }, error = function(e) {
    list(success = FALSE, error = e$message)
  })
}

#* Generate confounding frontier
#* @param data:object The dataset as JSON (optional, for benchmarking)
#* @param treatment:str Treatment variable name
#* @param outcome:str Outcome variable name
#* @param covariates:arr Covariate names
#* @param alpha_min:num Minimum alpha (-2)
#* @param alpha_max:num Maximum alpha (2)
#* @param gamma_min:num Minimum gamma (-2)
#* @param gamma_max:num Maximum gamma (2)
#* @param grid_size:int Grid resolution (25)
#* @post /frontier
function(data = NULL, treatment = NULL, outcome = NULL, covariates = NULL,
         alpha_min = -2, alpha_max = 2, 
         gamma_min = -2, gamma_max = 2,
         grid_size = 25) {
  
  tryCatch({
    spec <- NULL
    
    if (!is.null(data) && !is.null(treatment) && !is.null(outcome)) {
      df <- as.data.frame(jsonlite::fromJSON(data))
      spec <- causal_spec(df, treatment, outcome, covariates)
    }
    
    result <- confounding_frontier(
      spec = spec,
      alpha_range = c(as.numeric(alpha_min), as.numeric(alpha_max)),
      gamma_range = c(as.numeric(gamma_min), as.numeric(gamma_max)),
      grid_size = as.integer(grid_size)
    )
    
    # Summarize the frontier
    grid_df <- result$grid
    
    list(
      success = TRUE,
      grid = grid_df,
      summary = list(
        safe_region_pct = mean(grid_df$delta < 0.1) * 100,
        moderate_region_pct = mean(grid_df$delta >= 0.1 & grid_df$delta < 0.25) * 100,
        danger_region_pct = mean(grid_df$delta >= 0.25) * 100,
        max_delta = max(grid_df$delta),
        min_delta = min(grid_df$delta)
      ),
      benchmarks = if (!is.null(result$benchmarks)) result$benchmarks else NULL,
      identification_threshold = result$identification_threshold
    )
    
  }, error = function(e) {
    list(success = FALSE, error = e$message)
  })
}

#* Transport effects to new population
#* @param source_data:object Source dataset as JSON
#* @param target_data:object Target dataset as JSON
#* @param treatment:str Treatment variable name
#* @param outcome:str Outcome variable name  
#* @param transport_vars:arr Variables for transport weighting
#* @post /transport
function(source_data, target_data, treatment, outcome, transport_vars = NULL) {
  
  tryCatch({
    source_df <- as.data.frame(jsonlite::fromJSON(source_data))
    target_df <- as.data.frame(jsonlite::fromJSON(target_data))
    
    spec <- causal_spec(source_df, treatment, outcome, transport_vars)
    
    result <- transport_deficiency(
      spec,
      target_data = target_df,
      transport_vars = transport_vars
    )
    
    list(
      success = TRUE,
      delta_transport = result$delta_transport,
      effective_sample_size = result$effective_sample_size,
      ate_source = result$ate_source,
      ate_target = result$ate_target,
      covariate_shift = result$covariate_shift,
      recommendation = if (result$delta_transport < 0.1) {
        "Low shift: transport appears reliable"
      } else if (result$delta_transport < 0.25) {
        "Moderate shift: interpret transported effects with caution"
      } else {
        "High shift: transport may be unreliable"
      }
    )
    
  }, error = function(e) {
    list(success = FALSE, error = e$message)
  })
}

# =============================================================================
# Error Handler
# =============================================================================

#* @plumber
function(pr) {
  pr %%>%%
    pr_set_error(function(req, res, err) {
      res$status <- 500
      list(
        success = FALSE,
        error = conditionMessage(err),
        time = Sys.time()
      )
    })
}
', port)
  
  writeLines(plumber_code, file.path(path, "plumber.R"))
  
  # Create run script
  run_script <- sprintf('
#!/usr/bin/env Rscript
# Run the CausalDef API

library(plumber)

pr <- plumb("%s/plumber.R")
pr$run(
  host = "0.0.0.0",
  port = %d,
  swagger = TRUE
)
', path, port)
  
  writeLines(run_script, file.path(path, "run_api.R"))
  
  # Create Dockerfile for deployment
  dockerfile <- sprintf('
FROM rstudio/plumber:latest

# Install causaldef dependencies
RUN R -e "install.packages(c(\'data.table\', \'checkmate\', \'cli\', \'ggplot2\', \'jsonlite\'))"

# Install causaldef (from GitHub or local)
# RUN R -e "remotes::install_github(\'denizakdemir/causaldef\')"
COPY . /app
RUN R -e "install.packages(\'/app\', repos = NULL, type = \'source\')"

# Copy API files
COPY %s /api

EXPOSE %d

ENTRYPOINT ["R", "-e", "pr <- plumber::plumb(\'/api/plumber.R\'); pr$run(host = \'0.0.0.0\', port = %d)"]
', path, port, port)
  
  writeLines(dockerfile, file.path(path, "Dockerfile"))
  
  # Create README
  readme <- sprintf('
# CausalDef REST API

Auto-generated API for the causaldef R package.

## Quick Start

```r
# In R
library(plumber)
pr <- plumb("%s/plumber.R")
pr$run(port = %d, swagger = TRUE)
```

Then visit: http://localhost:%d/__docs__/

## Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| GET | /health | Health check |
| GET | /methods | List available methods |
| POST | /deficiency | Estimate Le Cam deficiency |
| POST | /policy-bound | Calculate policy regret bound |
| POST | /frontier | Generate confounding frontier |
| POST | /transport | Transport effects to new population |

## Example: Python Client

```python
import requests
import pandas as pd

# Prepare data
data = pd.DataFrame({
    "W": [1.2, -0.5, 0.8, ...],
    "A": [1, 0, 1, ...],
    "Y": [3.5, 2.1, 4.2, ...]
}).to_json(orient="records")

# Call API
response = requests.post(
    "http://localhost:%d/deficiency",
    json={
        "data": data,
        "treatment": "A",
        "outcome": "Y",
        "covariates": ["W"],
        "methods": ["iptw", "aipw"]
    }
)

result = response.json()
print(f"Best method: {result[\'best_method\']}")
print(f"Deficiency: {result[\'estimates\']}")
```

## Docker Deployment

```bash
docker build -t causaldef-api .
docker run -p %d:%d causaldef-api
```
', path, port, port, port, port, port)
  
  writeLines(readme, file.path(path, "README.md"))
  
  cli::cli_alert_success("Created Plumber API in {.file {path}}")
  cli::cli_alert_info("Run with: {.code plumber::plumb('{path}/plumber.R')$run(port = {port})}")
  cli::cli_alert_info("Swagger docs at: http://localhost:{port}/__docs__/")
  
  invisible(path)
}

#' Run CausalDef API Server
#'
#' Convenience function to start the plumber API server
#'
#' @param port Integer: port number (default 8080)
#' @param swagger Logical: enable Swagger UI (default TRUE)
#' @param path Character: path to API files (will create if missing)
#'
#' @export
run_causaldef_api <- function(port = 8080, swagger = TRUE, path = NULL) {
  
  if (!requireNamespace("plumber", quietly = TRUE)) {
    cli::cli_abort(c(
      "Package {.pkg plumber} is required for the API.",
      "i" = "Install with: {.code install.packages('plumber')}"
    ))
  }
  
  # Create temporary API if path not specified
  if (is.null(path)) {
    path <- file.path(tempdir(), "causaldef_api")
    create_plumber_api(path, port = port)
  }
  
  api_file <- file.path(path, "plumber.R")
  if (!file.exists(api_file)) {
    cli::cli_abort("API file not found: {.file {api_file}}")
  }
  
  cli::cli_alert_info("Starting CausalDef API on port {port}...")
  cli::cli_alert_info("Swagger UI: http://localhost:{port}/__docs__/")
  
  pr <- plumber::plumb(api_file)
  pr$run(host = "0.0.0.0", port = port, swagger = swagger)
}
